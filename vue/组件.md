## 全局注册组件

>  项目的`main.js函数`中 声明

```JavaScript
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

import HelloWorld from './components/HelloWorld.vue'

const vm=createApp(App)
    .component('Hello-World',HelloWorld) //对应的html标签是``Hello-World
    .mount('#app')

```



注册以后可以直接再其他页面上以`标签`的形式使用组件 `HelloWorld`,对应的html标签是``'HelloWorld'``

## 样式穿透

```JavaScript
<style scoped>
:deep(h1){
    color:red;
}
</style>

```

`:deep(h1)`**:子组件中所有`h1标签`样式都与父组件相同**,应该将:deep写入到父组件中





## 传递`props`

> **子组件**中显式声明 传入的`props` 名称,注意`foo是一个对象`

```vue
<script setup>
const props=defineProps({
    foo: Number //指定类型
})
</script>
<template>
    <div>
        <h1>
            {{props.foo+1}}
        </h1>
    </div>
</template>
```

> **父组件**在组件标签中`传递props`过去
**非string类型的props值,要使用v-bind命令传过去****

```vue
<hello-world :foo=347 />
```



## 动态绑定props,响应式

```vue
<script setup>
import HelloWorld from "./components/HelloWorld.vue";
import {ref} from 'vue'
let a=ref({'b':34545567,'c':'rtewertwer'})
</script>

<template>
    <div>
        <el-button type="success">success</el-button>
        <h1>fasdfasgas</h1>
        <hello-world :foo='a.b' :title="a.c"/>
    </div>
</template>
<style scoped>
:deep(h1) {
    color: red
}
</style>

```

**修改父组件中`a.b的值`,子组件中`<h1>{{props.foo}}</h1>` 的值会响应改变**



## element plus组件 (标签都是组件)

在单文件组件中直接使用全局 CSS 样式规则，即不加 `scoped` 属性的样式，可以对组件产生未知的影响。因为这样的样式会影响到所有同名标签，不论它们在哪个 Vue 组件内部，这就可能导致样式冲突和覆盖等问题，影响应用程序的正确性和可维护性。

因此，我们通常不建议在 Element Plus 中使用全局 CSS 样式来修改组件的外观，而是建议使用局部作用域 CSS 或自定义类名来实现组件定制化的样式需求。

如果您一定需要在全局 CSS 中直接修改 Element Plus 组件的样式，可以使用 `!important` 关键字来强制应用样式规则，例如：

```css
.el-container {
  color: red !important;
}
```

上面的代码在全局 CSS 样式表中直接选中了 `<el-container>` 组件，并且使用 `!important` 声明了 `color` 样式属性的优先级，这样就可以将颜色强制设置为红色。然而，这种方法通常不够灵活和可维护，因此请谨慎使用。



## 
